/**
 * @fileoverview The factory of `ConfigArray` objects.
 *
 * This class provides methods to create `ConfigArray` instance.
 *
 * - `create(configData, options)`
 *     Create a `ConfigArray` instance from a config data. This is to handle CLI
 *     options except `--config`.
 * - `loadFile(filePath, options)`
 *     Create a `ConfigArray` instance from a config file. This is to handle
 *     `--config` option. If the file was not found, throws the following error:
 *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.
 *      - If the filename was `package.json`, an IO error or an
 *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.
 *      - Otherwise, an IO error such as `ENOENT`.
 * - `loadInDirectory(directoryPath, options)`
 *     Create a `ConfigArray` instance from a config file which is on a given
 *     directory. This tries to load `.eslintrc.*` or `package.json`. If not
 *     found, returns an empty `ConfigArray`.
 * - `loadESLintIgnore(filePath)`
 *     Create a `ConfigArray` instance from a config file that is `.eslintignore`
 *     format. This is to handle `--ignore-path` option.
 * - `loadDefaultESLintIgnore()`
 *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in
 *     the current working directory.
 *
 * `ConfigArrayFactory` class has the responsibility that loads configuration
 * files, including loading `extends`, `parser`, and `plugins`. The created
 * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.
 *
 * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class
 * handles cascading and hierarchy.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

import debugOrig from "debug";
import fs from "fs";
import importFresh from "import-fresh";
import { createRequire } from "module";
import path from "path";
import stripComments from "strip-json-comments";

import {
    ConfigArray,
    ConfigDependency,
    IgnorePattern,
    OverrideTester
} from "./config-array/index.js";
import ConfigValidator from "./shared/config-validator.js";
import * as naming from "./shared/naming.js";
import * as ModuleResolver from "./shared/relative-module-resolver.js";

const require = createRequire(import.meta.url);

const debug = debugOrig("eslintrc:config-array-factory");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const configFilenames = [
    ".eslintrc.js",
    ".eslintrc.cjs",
    ".eslintrc.yaml",
    ".eslintrc.yml",
    ".eslintrc.json",
    ".eslintrc",
    "package.json"
];

// Define types for VSCode IntelliSense.
/** @typedef {import("./shared/types").ConfigData} ConfigData */
/** @typedef {import("./shared/types").OverrideConfigData} OverrideConfigData */
/** @typedef {import("./shared/types").Parser} Parser */
/** @typedef {import("./shared/types").Plugin} Plugin */
/** @typedef {import("./shared/types").Rule} Rule */
/** @typedef {import("./config-array/config-dependency").DependentParser} DependentParser */
/** @typedef {import("./config-array/config-dependency").DependentPlugin} DependentPlugin */
/** @typedef {ConfigArray[0]} ConfigArrayElement */

/**
 * @typedef {Object} ConfigArrayFactoryOptions
 * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.
 * @property {string} [cwd] The path to the current working directory.
 * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.
 * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.
 * @property {Object} [resolver=ModuleResolver] The module resolver object.
 * @property {string} eslintAllPath The path to the definitions for eslint:all.
 * @property {Function} getEslintAllConfig Returns the config data for eslint:all.
 * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.
 * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.
 */

/**
 * @typedef {Object} ConfigArrayFactoryInternalSlots
 * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.
 * @property {string} cwd The path to the current working directory.
 * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.
 * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.
 * @property {Object} [resolver=ModuleResolver] The module resolver object.
 * @property {string} eslintAllPath The path to the definitions for eslint:all.
 * @property {Function} getEslintAllConfig Returns the config data for eslint:all.
 * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.
 * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.
 */

/**
 * @typedef {Object} ConfigArrayFactoryLoadingContext
 * @property {string} filePath The path to the current configuration.
 * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
 * @property {string} name The name of the current configuration.
 * @property {string} pluginBasePath The base path to resolve plugins.
 * @property {"config" | "ignore" | "implicit-processor"} type The type of the current configuration. This is `"config"` in normal. This is `"ignore"` if it came from `.eslintignore`. This is `"implicit-processor"` if it came from legacy file-extension processors.
 */

/**
 * @typedef {Object} ConfigArrayFactoryLoadingContext
 * @property {string} filePath The path to the current configuration.
 * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
 * @property {string} name The name of the current configuration.
 * @property {"config" | "ignore" | "implicit-processor"} type The type of the current configuration. This is `"config"` in normal. This is `"ignore"` if it came from `.eslintignore`. This is `"implicit-processor"` if it came from legacy file-extension processors.
 */

/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */
const internalSlotsMap = new WeakMap();

/** @type {WeakMap<object, Plugin>} */
const normalizedPlugins = new WeakMap();

/**
 * Check if a given string is a file path.
 * @param {string} nameOrPath A module name or file path.
 * @returns {boolean} `true` if the `nameOrPath` is a file path.
 */
function isFilePath(nameOrPath) {
    return (
        /^\.{1,2}[/\\]/u.test(nameOrPath) ||
        path.isAbsolute(nameOrPath)
    );
}

/**
 * Convenience wrapper for synchronously reading file contents.
 * @param {string} filePath The filename to read.
 * @returns {string} The file contents, with the BOM removed.
 * @private
 */
function readFile(filePath) {
    return fs.readFileSync(filePath, "utf8").replace(/^\ufeff/u, "");
}

/**
 * Loads a YAML configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */
function loadYAMLConfigFile(filePath) {
    debug(`Loading YAML config file: ${filePath}`);

    // lazy load YAML to improve performance when not used
    const yaml = require("js-yaml");

    try {

        // empty YAML file can be null, so always use
        return yaml.load(readFile(filePath)) || {};
    } catch (e) {
        debug(`Error reading YAML file: ${filePath}`);
        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
        throw e;
    }
}

/**
 * Loads a JSON configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */
function loadJSONConfigFile(filePath) {
    debug(`Loading JSON config file: ${filePath}`);

    try {
        return JSON.parse(stripComments(readFile(filePath)));
    } catch (e) {
        debug(`Error reading JSON file: ${filePath}`);
        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
        e.messageTemplate = "failed-to-read-json";
        e.messageData = {
            path: filePath,
            message: e.message
        };
        throw e;
    }
}

/**
 * Loads a legacy (.eslintrc) configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */
function loadLegacyConfigFile(filePath) {
    debug(`Loading legacy config file: ${filePath}`);

    // lazy load YAML to improve performance when not used
    const yaml = require("js-yaml");

    try {
        return yaml.load(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};
    } catch (e) {
        debug("Error reading YAML file: %s\n%o", filePath, e);
        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
        throw e;
    }
}

/**
 * Loads a JavaScript configuration from a file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */
function loadJSConfigFile(filePath) {
    debug(`Loading JS config file: ${filePath}`);
    try {
        return importFresh(filePath);
    } catch (e) {
        debug(`Error reading JavaScript file: ${filePath}`);
        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
        throw e;
    }
}

/**
 * Loads a configuration from a package.json file.
 * @param {string} filePath The filename to load.
 * @returns {ConfigData} The configuration object from the file.
 * @throws {Error} If the file cannot be read.
 * @private
 */
function loadPackageJSONConfigFile(filePath) {
    debug(`Loading package.json config file: ${filePath}`);
    try {
        const packageData = loadJSONConfigFile(filePath);

        if (!Object.hasOwnProperty.call(packageData, "eslintConfig")) {
            throw Object.assign(
                new Error("package.json file doesn't have 'eslintConfig' field."),
                { code: "ESLINT_CONFIG_FIELD_NOT_FOUND" }
            );
        }

        return packageData.eslintConfig;
    } catch (e) {
        debug(`Error reading package.json file: ${filePath}`);
        e.message = `Cannot read config file: ${filePath}\nError: ${e.message}`;
        throw e;
    }
}

/**
 * Loads a `.eslintignore` from a file.
 * @param {string} filePath The filename to load.
 * @returns {string[]} The ignore patterns from the file.
 * @private
 */
function loadESLintIgnoreFile(filePath) {
    debug(`Loading .eslintignore file: ${filePath}`);

    try {
        return readFile(filePath)
            .split(/\r?\n/gu)
            .filter(line => line.trim() !== "" && !line.startsWith("#"));
    } catch (e) {
        debug(`Error reading .eslintignore file: ${filePath}`);
        e.message = `Cannot read .eslintignore file: ${filePath}\nError: ${e.message}`;
        throw e;
    }
}

/**
 * Creates an error to notify about a missing config to extend from.
 * @param {string} configName The name of the missing config.
 * @param {string} importerName The name of the config that imported the missing config
 * @param {string} messageTemplate The text template to source error strings from.
 * @returns {Error} The error object to throw
 * @private
 */
function configInvalidError(configName, importerName, messageTemplate) {
    return Object.assign(
        new Error(`Failed to load config "${configName}" to extend from.`),
        {
            messageTemplate,
            messageData: { configName, importerName }
        }
    );
}

/**
 * Loads a configuration file regardless of the source. Inspects the file path
 * to determine the correctly way to load the config file.
 * @param {string} filePath The path to the configuration.
 * @returns {ConfigData|null} The configuration information.
 * @private
 */
function loadConfigFile(filePath) {
    switch (path.extname(filePath)) {
        case ".js":
        case ".cjs":
            return loadJSConfigFile(filePath);

        case ".json":
            if (path.basename(filePath) === "package.json") {
                return loadPackageJSONConfigFile(filePath);
            }
            return loadJSONConfigFile(filePath);

        case ".yaml":
        case ".yml":
            return loadYAMLConfigFile(filePath);

        default:
            return loadLegacyConfigFile(filePath);
    }
}

/**
 * Write debug log.
 * @param {string} request The requested module name.
 * @param {string} relativeTo The file path to resolve the request relative to.
 * @param {string} filePath The resolved file path.
 * @returns {void}
 */
function writeDebugLogForLoading(request, relativeTo, filePath) {
    /* istanbul ignore next */
    if (debug.enabled) {
        let nameAndVersion = null;

        try {
            const packageJsonPath = ModuleResolver.resolve(
                `${request}/package.json`,
                relativeTo
            );
            const { version = "unknown" } = require(packageJsonPath);

            nameAndVersion = `${request}@${version}`;
        } catch (error) {
            debug("package.json was not found:", error.message);
            nameAndVersion = request;
        }

        debug("Loaded: %s (%s)", nameAndVersion, filePath);
    }
}

/**
 * Create a new context with default values.
 * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.
 * @param {"config" | "ignore" | "implicit-processor" | undefined} providedType The type of the current configuration. Default is `"config"`.
 * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.
 * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.
 * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.
 * @returns {ConfigArrayFactoryLoadingContext} The created context.
 */
function createContext(
    { cwd, resolvePluginsRelativeTo },
    providedType,
    providedName,
    providedFilePath,
    providedMatchBasePath
) {
    const filePath = providedFilePath
        ? path.resolve(cwd, providedFilePath)
        : "";
    const matchBasePath =
        (providedMatchBasePath && path.resolve(cwd, providedMatchBasePath)) ||
        (filePath && path.dirname(filePath)) ||
        cwd;
    const name =
        providedName ||
        (filePath && path.relative(cwd, filePath)) ||
        "";
    const pluginBasePath =
        resolvePluginsRelativeTo ||
        (filePath && path.dirname(filePath)) ||
        cwd;
    const type = providedType || "config";

    return { filePath, matchBasePath, name, pluginBasePath, type };
}

/**
 * Normalize a given plugin.
 * - Ensure the object to have four properties: configs, environments, processors, and rules.
 * - Ensure the object to not have other properties.
 * @param {Plugin} plugin The plugin to normalize.
 * @returns {Plugin} The normalized plugin.
 */
function normalizePlugin(plugin) {

    // first check the cache
    let normalizedPlugin = normalizedPlugins.get(plugin);

    if (normalizedPlugin) {
        return normalizedPlugin;
    }

    normalizedPlugin = {
        configs: plugin.configs || {},
        environments: plugin.environments || {},
        processors: plugin.processors || {},
        rules: plugin.rules || {}
    };

    // save the reference for later
    normalizedPlugins.set(plugin, normalizedPlugin);

    return normalizedPlugin;
}

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The factory of `ConfigArray` objects.
 */
class ConfigArrayFactory {

    /**
     * Initialize this instance.
     * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.
     */
    constructor({
        additionalPluginPool = new Map(),
        cwd = process.cwd(),
        resolvePluginsRelativeTo,
        builtInRules,
        resolver = ModuleResolver,
        eslintAllPath,
        getEslintAllConfig,
        eslintRecommendedPath,
        getEslintRecommendedConfig
    } = {}) {
        internalSlotsMap.set(this, {
            additionalPluginPool,
            cwd,
            resolvePluginsRelativeTo:
                resolvePluginsRelativeTo &&
                path.resolve(cwd, resolvePluginsRelativeTo),
            builtInRules,
            resolver,
            eslintAllPath,
            getEslintAllConfig,
            eslintRecommendedPath,
            getEslintRecommendedConfig
        });
    }

    /**
     * Create `ConfigArray` instance from a config data.
     * @param {ConfigData|null} configData The config data to create.
     * @param {Object} [options] The options.
     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
     * @param {string} [options.filePath] The path to this config data.
     * @param {string} [options.name] The config name.
     * @returns {ConfigArray} Loaded config.
     */
    create(configData, { basePath, filePath, name } = {}) {
        if (!configData) {
            return new ConfigArray();
        }

        const slots = internalSlotsMap.get(this);
        const ctx = createContext(slots, "config", name, filePath, basePath);
        const elements = this._normalizeConfigData(configData, ctx);

        return new ConfigArray(...elements);
    }

    /**
     * Load a config file.
     * @param {string} filePath The path to a config file.
     * @param {Object} [options] The options.
     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
     * @param {string} [options.name] The config name.
     * @returns {ConfigArray} Loaded config.
     */
    loadFile(filePath, { basePath, name } = {}) {
        const slots = internalSlotsMap.get(this);
        const ctx = createContext(slots, "config", name, filePath, basePath);

        return new ConfigArray(...this._loadConfigData(ctx));
    }

    /**
     * Load the config file on a given directory if exists.
     * @param {string} directoryPath The path to a directory.
     * @param {Object} [options] The options.
     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.
     * @param {string} [options.name] The config name.
     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.
     */
    loadInDirectory(directoryPath, { basePath, name } = {}) {
        const slots = internalSlotsMap.get(this);

        for (const filename of configFilenames) {
            const ctx = createContext(
                slots,
                "config",
                name,
                path.join(directoryPath, filename),
                basePath
            );

            if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {
                let configData;

                try {
                    configData = loadConfigFile(ctx.filePath);
                } catch (error) {
                    if (!error || error.code !== "ESLINT_CONFIG_FIELD_NOT_FOUND") {
                        throw error;
                    }
                }

                if (configData) {
                    debug(`Config file found: ${ctx.filePath}`);
                    return new ConfigArray(
                        ...this._normalizeConfigData(configData, ctx)
                    );
                }
            }
        }

        debug(`Config file not found on ${directoryPath}`);
        return new ConfigArray();
    }

    /**
     * CheÂLÂÑ„2·ÈJşO8»{t(ön©•¼©şªP°”~•Ò{Uûø¾•¼5Y–¹Ÿ‘äU’ ÜVÉ­­ÉôeJß&k¿QÚv˜¦cİ*ÇaÌeØÃ%^ÃôUSô¢z­uüÉBÓtUÚºTÕ3LK?ˆ‚uk’–ÖúCŸdCŸŒ†¿N/†o’*%,Â„sHé?õf…±díØ+;ÿ=ÿ×:Û	ß$ÜOx°û¸‰ä4µíRÉ-j­µü’Û¦£¼E:öÂ7{Ñ&½±}š¶øï€NOÒIIÇfZib®MÖrÿµ…‰€ô§X¥et=•é5dÿ%«Ü·Hrjüøyc3$9Ov¾!ÉÏ‹|«Êÿ¶*Û,ãái9úŞXoHö¨]ö(ñ}’Û’‡íÈÃ:ò°}ÍÆ¥XI4ÉN’üMrĞjŞYÏëôÄŒ#yû¿(UÑxÈ¹ÉYÉg‘Íù”~¢{šZ5‹$Ïg<|•ø7‘/çÚ–ô¿[[¶’şVhPëZÛ—ñßV¹æÈĞşã€¶ì" »E¥ê©w¿QïD—‰‡L”xfâXÿFñĞ4÷7Š„d­u¦€Hˆ´g	€,%Së¯µı¬ÌneS)ïbÄ
J_ÌĞìÌ¡z'ùÂã”»%SÃ×­p¯!<AøµášUo‘å_©¿vYôö ,ŠÂ3é–Ê†ÆÂVí­UÚ>«#k­³PÓ¤Ôq*u‘<¹•zŠ¥ìYOÒÌ¤R9”–Ö&DöNÖ2%íÌ´Òy,ËâË.)­-¡²Ë²4‰uTYÅaÓ¨¶Ö|šÒÖ¹/Ä.KM©;ª÷5J¿Ax2ëAı¦±}t®ş„wIòŸ&iKÿ%mÃş"‰ıpLë)í4üÁzİñ…>¬¡œÃµÕ@×ìdZ‹4¹%7…"£¢"Ç½¡c1ÖIlXw+‰L'Ğ¦ì‹¬k†UZÊgĞZ'%s¬vóVû»ÔLšR¢Yh<úÖ:ïYH×â9‘Vq¤iRr<SÕ×4ÿ»´3—|%õçÎ'|²	Ê¶­l2^MqĞp¬eóp\I¶“ş+µç¸•¹\nIC¼Qz ÕIxtM)¹;üÁuÕz¥•¹Ò‡|Ök?‚ìŒ°H,vbşÏ3ŞÿuŞ“iÕ"%¯e¡bGXz*XÂmÜ{P’ş˜t’¡\É'Ğf±ukG Í”»„4W“…—H²“$/‘ä]²yœäç©Ôw#pDd-õ#´°Æ¦»ç 5Ç‘ZÚÙ*-Kím8?7„¦*k©¸ÚRºÉP%6J"cR“s6œÒÙMÒ2†M#µ(’~«ùp´öªìï²‘Ó6Ê	Ò«#µ^4õ’µÎÏõ¢kŸ#q,öŒÄ}ö£‘¸Ï‰;õMÒ¹7uìG¡ç(Ô	…:İGim<J›¹™CqµÌ…¥öåÈòY²|Óªåyd¡x”æ¥L«Y&çWb“y6LÓ×4-i¹ßÉ‘5êÁ\k?Ëº–“Î+|…ğ-Âw¨_)}Œğ,I¾±’üBøÉiƒÇFcÚ}4¦ƒÒ”q"ãm™•ObG[P°øÒ0—G?Ørëû­&’E4î‰£ÿ7ûÚ™Ö‚—J­ÑbÃ9â»Îàãç8¦gğ	…?ä´‡O4|BY3– ŸîğÁt"k¼9ğæÀ›oÁRáÊ\¡¼+ıõgnPÖÒn,“y¾	Ÿîğ	…O"ó™7Ÿ\øŒ„Owø„Â'‘€,òC@²…‚íPø/ì†ÁßDèF*›5WÂg$|ºÃ'>‰ğ©aØøÌfƒ@ÈCCz0¥3Y:[¥`£ØRø<ÁF³§áãÎÆ@é1 3­‚ÏsğYÏ²ÙÌÈ¶2ü×ĞMğ™3è›A¿œí`ÀkÙ›ğq‡Ïøì€O(Ô~>îğ9Œ¿úÀ§üÙv>îğ9ŸğÁ-uîâÈ:'ê]’ÂYozËÂr—$§†ï XÊÆùÖ·\Ê^L¥ß–]foG·òæø$7¯ëÚ=0ÇuK\Üm@`.Û;Ù©ÆïgÍ&\èèº”p•~Ÿ¿p+áÂİ„$<G¥.SúáO„÷¹-¢ğT´·-Şy´ÅÃ	õÑ0„Ş¢Òøˆz÷æ6w
!ôc»Ç>ØãÇğ)Ñzw„µ$]vÇ¸1|ŸC76¶÷‘˜\ºcèÇÒ£ÎCîÁ±—ñ-~ìÄØÉNß
áÇğm!ÊJ¢~ÏÍÎ­‰fø hvgìœ¥ôôK8}©gŒ»ã-ÜÇé\mñ	Õ…c´tÿ;Æ›ãÓ=‰¶Ÿ¶·‹Íµ)÷Hl¢mù¸4§¥kYÊ±&òF¢í¢q™î‰¶ß¶ïk²]1.4Ÿ—BéA±zzö|;ÙöåqIN5ÊÎF—1 ùá8WÄÜØU`sBìqaÜ‰¶ßŒ[¹¿Œ{!6Õ†e¿’hš½-í¼[c›“ s]Ê¸˜üp÷*—…¿3^È?s¿»ÕıÍğ·Më¡/·b½9>·´Û{´Û¶¶# FÔÛ‘^¥~Š=b‹íYÏw¹ã‚økì@Çh†>ÈĞcC~'9”áÓoC>w6”~¸ƒ/ÍNvºl;×wÃ¶[›Nq‰¶Û²{ÄÍ¶­
ëgbø6	Ãç/MŸŒØÍñ‰ˆİô›8o›}ÙÃãîQ,%ÚÍÆ±ø2Û.ÖDQÇíş“=>Noç“ääl‡:,-çHL¢íˆ«7IÆ0…19c(B2XNÂ¼¸àáÇâÚI_’üåÛ~pìháw9‚LªŞÛ9‡âÁÚ‘¸#4²Cm°…Cm°…Cmğé‘p»¹î®Gx¯Üú–GxFîmÏhĞïØñ<·[Ç;|‹C¢>·“`·67½cÅpÅp¢¾)*Ñn. UaÕ/ó]¹›:¥ö§Ú­óx©cªİÙÜ ùÚeg®lÃÏ¹:×\»¿sÛ2ILvnyw¼A-œL’<&ï³“íğo	v—¼¿ ËØÚŸx¿<Öi6é oÏ¶Ãßù…Û•å¹CznJğiÙ…vİÚøuÈğ‰±
šAÓa®ÅtÂ˜ü $ÁnU^çNÑâÍ¼nÑâ`^ŸÍÕé2¿”‡#u'Ï.vÕ²ŞÎ?¿¢Ó*»ù!^Î¢Kşg1 _çzÓzÂGB:Áßg±ôWw:@¥¼m6ç¯ï´
FpK§#v¨YGQç,®äîtÒÛsÒçìVq'ÿÏ:ŠÃUvûÃ`uâ‚ÍUvú‚o;9üÕŒ#ÌAgá_p£S­±Î"¡€Ç¯²K/°wy7İœÅä‚ñ‰¶3Ú2oñm@t<z Kü=À>ñ‹¨ï\‡-YDŞĞë¾(D¶Vü]P¿9'Ç{“Îrjí"Âå{‹¾gÔ¾0~ş*»ã³ñ[E?ãhC]Wîê,ºwx	rqeË¥g–Sô&Ú®‰¹mË6~Ÿ@öqméâ¾Ğnšq]ìB»yÆŸ¡µOOÕ½’¡ 3¹ó&æ9>ÉiÄü‘˜MĞ’'½]HDÊxS“®x|Y“À=e¶ãs¡[»”ì¯¢ô&¡¾äGØÅĞ?ºm¥ÜÉTÖ¤+ŸcFk…f“˜7Ál,ÖM¨6ïÖ¥GÍ4çŠãQóÌGtèó“º7ŸÔıLÈu®'u.„~…Ié¡"¡p‹ù²n^á+PöåÂ]æTq¬ğ™Û£…\ao:j*œL§ÌzûlÓ9³³=şf U,1İ0Ú§Gİ6‡Ûo1Á
`ÿ¦éº‹7H¸s{¯hJ›tGMöåCÅYÓ#åÎâª	küÙ3Zğ‰è¬e9í)&‘41¸|¶91¢Èş¥‰ÊèĞÚzöÎÄAå»h…ÙEc„‘Y6œ]>Ô>tÒ]4î#í1~VÙLÚòŠI/Åã,Ø	š¸V;‹Ù“ Ô»Uvk&]/¯uéGÀ—&ıâ‰sí¨ı¼ÆbEÑl±Î«UÅdû?&…VÔØ‡µŒ+‚™kß¿è¦›Éõ‘ş!ÚÑzˆÚyˆZ…³rGÅzkÂzQYtÒsŠt®ë©=ë®ŞëÅ²¢¯A¾±Óoıâ¹^|:ÇÈò1jÉ1šÇhvœ¦x»îSy"<¾ò{Z“ïÒ»ú¾§µ÷.½±ï>µä
Å¹-­ZÉfsvÜh'=ÍN‰9MqëÇñ÷wâEêÑE²`Ë1}ŸÚ`Ë¥D¦ãº¹N	áKÛM¹H¹Îâ?ExÖØ-NsÂÕIï™j?ºx[ùVû’â·¦¬·Ç_
®âßåìŸÁqLOÚ.şÒhßYÔ£O(Ö{FP-¸Û¶©Ú!^)îPµâªcÕzVÖ$»‹ûV­â§ŠGVí¦¨Û¹9Uq{-.¨Š8^ÑâNñGU	âo°|ÄŞ³¤G§“Ğ†óUçì»• ddÉåªõ¢ Ò—ù¼’{U?Üı×Äü¤dLÔ/İ¨µ}è=W9®*İèı[İ8¾ë*ƒ|Áiï#yù'‚ü3J¬.€Róâ2èZt¦Š/”p×hñá{%UG‹ÏJ6ÁN„ÑRDuUP]©våã6Ts‡Û%›«!·÷,]écÕzZ«^+;_íìp°,ÍÉ›$Ş×Ë]½êö“oW‚ü—êà™¿ÛL†]Itü‡â/Ä Ép.Y
»¹¤3™k<@1¼fâ>ë}?‰9`ÿ'±hrTÍzñôd˜³bídÇ—&'9M'ÏÔQ_Q_¦ÓÈ.'É%A¿m"\/vB©8¾ÊîÂä`óg8fæ®qcõ†í#æÍÕ¸w§xlçæ'îlv‡9i¾é¶^t7cÒÌç*îSo§±ØÎÇ™€}\vQÖ‹<s’Ó>jáv…S@V{°¶Fj¶-®*ûhLõô{G=›o7õéâøö´C”»‹$¶Ô‹ûLö%÷iã8OOsœ§»Hç4Çyº‰ZrŒâ!ÁWş‹$¹B6/’æE«Ê¾&F?í
¤[¢ç/R¿.ÒÜ¹Hïc»Bx‘ËßÉÚéê€ãÊàÇqM8Dÿ<¿‹ãµÀ]×÷IrŸZrŸ®läïÓ*}Ÿa$7Én#ÙM fÇk«Cä«…v¦\¶Ğnò”ëÓB¶<D`_"ÍA3B`ËC("°å!‚æaœÀvÆ	lg*yÃÛ&©{ëéC)ªGvØş>‚®M@òXÜP‡.}§§:|3xºÉáû)iN÷x«ª9ÓkÆD- Lormalized config.
     * @private
     */
    _normalizeConfigData(configData, ctx) {
        const validator = new ConfigValidator();

        validator.validateConfigSchema(configData, ctx.name || ctx.filePath);
        return this._normalizeObjectConfigData(configData, ctx);
    }

    /**
     * Normalize a given config to an array.
     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */
    *_normalizeObjectConfigData(configData, ctx) {
        const { files, excludedFiles, ...configBody } = configData;
        const criteria = OverrideTester.create(
            files,
            excludedFiles,
            ctx.matchBasePath
        );
        const elements = this._normalizeObjectConfigDataBody(configBody, ctx);

        // Apply the criteria to every element.
        for (const element of elements) {

            /*
             * Merge the criteria.
             * This is for the `overrides` entries that came from the
             * configurations of `overrides[].extends`.
             */
            element.criteria = OverrideTester.and(criteria, element.criteria);

            /*
             * Remove `root` property to ignore `root` settings which came from
             * `extends` in `overrides`.
             */
            if (element.criteria) {
                element.root = void 0;
            }

            yield element;
        }
    }

    /**
     * Normalize a given config to an array.
     * @param {ConfigData} configData The config data to normalize.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */
    *_normalizeObjectConfigDataBody(
        {
            env,
            extends: extend,
            globals,
            ignorePatterns,
            noInlineConfig,
            parser: parserName,
            parserOptions,
            plugins: pluginList,
            processor,
            reportUnusedDisableDirectives,
            root,
            rules,
            settings,
            overrides: overrideList = []
        },
        ctx
    ) {
        const extendList = Array.isArray(extend) ? extend : [extend];
        const ignorePattern = ignorePatterns && new IgnorePattern(
            Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],
            ctx.matchBasePath
        );

        // Flatten `extends`.
        for (const extendName of extendList.filter(Boolean)) {
            yield* this._loadExtends(extendName, ctx);
        }

        // Load parser & plugins.
        const parser = parserName && this._loadParser(parserName, ctx);
        const plugins = pluginList && this._loadPlugins(pluginList, ctx);

        // Yield pseudo config data for file extension processors.
        if (plugins) {
            yield* this._takeFileExtensionProcessors(plugins, ctx);
        }

        // Yield the config data except `extends` and `overrides`.
        yield {

            // Debug information.
            type: ctx.type,
            name: ctx.name,
            filePath: ctx.filePath,

            // Config data.
            criteria: null,
            env,
            globals,
            ignorePattern,
            noInlineConfig,
            parser,
            parserOptions,
            plugins,
            processor,
            reportUnusedDisableDirectives,
            root,
            rules,
            settings
        };

        // Flatten `overries`.
        for (let i = 0; i < overrideList.length; ++i) {
            yield* this._normalizeObjectConfigData(
                overrideList[i],
                { ...ctx, name: `${ctx.name}#overrides[${i}]` }
            );
        }
    }

    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */
    _loadExtends(extendName, ctx) {
        debug("Loading {extends:%j} relative to %s", extendName, ctx.filePath);
        try {
            if (extendName.startsWith("eslint:")) {
                return this._loadExtendedBuiltInConfig(extendName, ctx);
            }
            if (extendName.startsWith("plugin:")) {
                return this._loadExtendedPluginConfig(extendName, ctx);
            }
            return this._loadExtendedShareableConfig(extendName, ctx);
        } catch (error) {
            error.message += `\nReferenced from: ${ctx.filePath || ctx.name}`;
            throw error;
        }
    }

    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */
    _loadExtendedBuiltInConfig(extendName, ctx) {
        const {
            eslintAllPath,
            getEslintAllConfig,
            eslintRecommendedPath,
            getEslintRecommendedConfig
        } = internalSlotsMap.get(this);

        if (extendName === "eslint:recommended") {
            const name = `${ctx.name} Â» ${extendName}`;

            if (getEslintRecommendedConfig) {
                if (typeof getEslintRecommendedConfig !== "function") {
                    throw new Error(`getEslintRecommendedConfig must be a function instead of '${getEslintRecommendedConfig}'`);
                }
                return this._normalizeConfigData(getEslintRecommendedConfig(), { ...ctx, name, filePath: "" });
            }
            return this._loadConfigData({
                ...ctx,
                name,
                filePath: eslintRecommendedPath
            });
        }
        if (extendName === "eslint:all") {
            const name = `${ctx.name} Â» ${extendName}`;

            if (getEslintAllConfig) {
                if (typeof getEslintAllConfig !== "function") {
                    throw new Error(`getEslintAllConfig must be a function instead of '${getEslintAllConfig}'`);
                }
                return this._normalizeConfigData(getEslintAllConfig(), { ...ctx, name, filePath: "" });
            }
            return this._loadConfigData({
                ...ctx,
                name,
                filePath: eslintAllPath
            });
        }

        throw configInvalidError(extendName, ctx.name, "extend-config-missing");
    }

    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */
    _loadExtendedPluginConfig(extendName, ctx) {
        const slashIndex = extendName.lastIndexOf("/");

        if (slashIndex === -1) {
            throw configInvalidError(extendName, ctx.filePath, "plugin-invalid");
        }

        const pluginName = extendName.slice("plugin:".length, slashIndex);
        const configName = extendName.slice(slashIndex + 1);

        if (isFilePath(pluginName)) {
            throw new Error("'extends' cannot use a file path for plugins.");
        }

        const plugin = this._loadPlugin(pluginName, ctx);
        const configData =
            plugin.definition &&
            plugin.definition.configs[configName];

        if (configData) {
            return this._normalizeConfigData(configData, {
                ...ctx,
                filePath: plugin.filePath || ctx.filePath,
                name: `${ctx.name} Â» plugin:${plugin.id}/${configName}`
            });
        }

        throw plugin.error || configInvalidError(extendName, ctx.filePath, "extend-config-missing");
    }

    /**
     * Load configs of an element in `extends`.
     * @param {string} extendName The name of a base config.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.
     * @private
     */
    _loadExtendedShareableConfig(extendName, ctx) {
        const { cwd, resolver } = internalSlotsMap.get(this);
        const relativeTo = ctx.filePath || path.join(cwd, "__placeholder__.js");
        let request;

        if (isFilePath(extendName)) {
            request = extendName;
        } else if (extendName.startsWith(".")) {
            request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.
        } else {
            request = naming.normalizePackageName(
                extendName,
                "eslint-config"
            );
        }

        let filePath;

        try {
            filePath = resolver.resolve(request, relativeTo);
        } catch (error) {
            /* istanbul ignore else */
            if (error && error.code === "MODULE_NOT_FOUND") {
                throw configInvalidError(extendName, ctx.filePath, "extend-config-missing");
            }
            throw error;
        }

        writeDebugLogForLoading(request, relativeTo, filePath);
        return this._loadConfigData({
            ...ctx,
            filePath,
            name: `${ctx.name} Â» ${request}`
        });
    }

    /**
     * Load given plugins.
     * @param {string[]} names The plugin names to load.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {Record<string,DependentPlugin>} The loaded parser.
     * @private
     */
    _loadPlugins(names, ctx) {
        return names.reduce((map, name) => {
            if (isFilePath(name)) {
                throw new Error("Plugins array cannot includes file paths.");
            }
            const plugin = this._loadPlugin(name, ctx);

            map[plugin.id] = plugin;

            return map;
        }, {});
    }

    /**
     * Load a given parser.
     * @param {string} nameOrPath The package name or the path to a parser file.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {DependentParser} The loaded parser.
     */
    _loadParser(nameOrPath, ctx) {
        debug("Loading parser %j from %s", nameOrPath, ctx.filePath);

        const { cwd, resolver } = internalSlotsMap.get(this);
        const relativeTo = ctx.filePath || path.join(cwd, "__placeholder__.js");

        try {
            const filePath = resolver.resolve(nameOrPath, relativeTo);

            writeDebugLogForLoading(nameOrPath, relativeTo, filePath);

            return new ConfigDependency({
                definition: require(filePath),
                filePath,
                id: nameOrPath,
                importerName: ctx.name,
                importerPath: ctx.filePath
            });
        } catch (error) {

            // If the parser name is "espree", load the espree of ESLint.
            if (nameOrPath === "espree") {
                debug("Fallback espree.");
                return new ConfigDependency({
                    definition: require("espree"),
                    filePath: require.resolve("espree"),
                    id: nameOrPath,
                    importerName: ctx.name,
                    importerPath: ctx.filePath
                });
            }

            debug("Failed to load parser '%s' declared in '%s'.", nameOrPath, ctx.name);
            error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;

            return new ConfigDependency({
                error,
                id: nameOrPath,
                importerName: ctx.name,
                importerPath: ctx.filePath
            });
        }
    }

    /**
     * Load a given plugin.
     * @param {string} name The plugin name to load.
     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.
     * @returns {DependentPlugin} The loaded plugin.
     * @private
     */
    _loadPlugin(name, ctx) {
        debug("Loading plugin ¾ğó-ü<èĞiæe8EÅµ`ì¤LÉá˜,ñmJZF2GıáˆçwàÌPFÀø«ÔóY¥ŞÚÄ)vÒû•nÜÿº±J¢º1È6µF7æĞ¬úæ´†œ×rA;»µ³G;§hçTíœ¦½ÚÙ§Óµs†vÎÔÎY¬š“|ßEe˜<À30Y`–s<OİºZš«QKsuÔÒ4[Ú^ÚQÚY:ª.tt]è˜ºĞ±u¡]‰úàd•Ò-~WëĞù`2ÑÕ gS™tè6•I‡S™t˜b*“SÉ1Ê,O#Çh³ÜK1f¹²ÍO'GWÂ,Ï`—Œp&»d}³ä#sªuœ‚‹B =
8!ñ» vş‚47ë„j?Ï_
Äã{¡»]|ŸGa¤¹hlÔ~Ø	Øˆ<*æt@íç€=‘€=Ñ€ÈÓâPû9à”HÀ)a@.‚âzMGÀtZÍüMûaWñ«ö+cñgš@û9º¾hPÔÅ?kbígâéQbÔ†âømCbíWQ£’wÓÚÏÜfF¹¡‹šXû™xeßR3pûs,4˜4‡kÏvÔ®R½)[^OÙ.Û6˜²É;!ı8Féƒß(›+£ûˆÆ6tÚİ±ÜºIò›4ôièãp`!5û_†¶UÓÍˆ³ñfÑÃˆÓ	ñD1…gâşb# Ä•
½/Şuljö©(J¶/İµ"Åå–¡º—_ §3ú„S*ôözñÃÍ©|w E‘õ9]'§òhIµÎGntMJåå4„²¨Åğ2ë~(yÒø‘Ãöç`?*ïï(/‡µûG©°~N£¤ÊnxĞ$wá;4¿™Ôl9Ñ5lİdIë]^ù1bB‘4(H×¤>—¤jÈ62ÇÂH%™™uY¨ŸÈŸÆL«!ƒš™V/“UlËIÔA4?“èö:P'ÓYêz­×Ùë¦½ì@«é™ÓxÜáSİi»$ã˜‘É_:.~*Ñí}	‰'ûDüà7%æÂ£·kÂVrûgt”Ğ=[äø‡cüøku[$ó.j(*#êªjÎ„¯0x‚?Ù`+­¯ï’­¤ô3)ÌúIÔ„^dlWjÃ·eò'lŞ*_ CZ}º:4Œİ~Œ²¶‹Ób¸•(/cü–š¸œ¦<!gBÉ‰Y<3ÃóÏß¦½Ux*#rÿ¬Ğ 9ø§Æpâ¡-g/n¿„U ¥sgl]Ë3‚+t>ØgÀŞñºmL<N*ñ¸âÜ¹ÆŠÍ—†ï=)å.=E*õzĞq®sİ¶&İ^O_}'åÌÉÜ,~_ò!*_–¡W¾.EÎ§{öÒ½ùéÌí¾İØZº7êÓ¾ ¿ş/Èoç/Èoõ¤;çÒ]ûéù‚tOAº×¿ İÇ_0ÿšæ}1ºÎ/H· .Ï:æš<ëÀw¸İ²ãê/Ò›/«]„§ÅóíÌpu}vÎ×ÎÚ¹½vî ;šáé…äÜç.š`gM°“&X¤	v5ÃeıİHá„Pj-¡vî:£h +Ş	õ
ÇëÀHL¸n#eáAãÉ&GàHs¦s8=ÜÈÖátdëÈƒDeëÄ‹ŒÈŒŠÀ9Caâ²âVºæ‘F6/Ìí
SÏ'LkÿP˜!ñÒC5±ö…yÃS|RkÿP˜a!1<ÅßÏ«*8†¶Ï
È™Bí½ c‹óÃ Ú?¤+
kˆ»„bºs u\œª™i¿Š,Š‹5ü]cÅ³NàaäPˆÌŠçBœÛÇØş<Ô“_9Aäaêá)®ÑÌµHWtz‘NJºk$) /ÑÌ´_%,Š÷k‚EÑ¤häPˆ’²ˆ“²¼*).Ç^|]3Ô~#ênñŸš`7*×œÀMVaÅ‹.ùİ"%¿‰ğRHÍœ†BNR¤UéeˆôŠ¯¨Únú[Û…¹Zl[îú ìôECX…ğBŞ)Ş)«}!µŞÓ#ÓùûÈY¼ƒ±bT:V[¾Déş^„à¿FzÖÑ¾— ~àõ¦üšô÷^ “t +,bÖÚ¨M#X!ØµÁe‚İB‚Û4Áƒu	"ŞÕ¥wĞ£/¦Ôáwób38 .µÁäJx“t±±­ô¾‰7Ï6Ïl{â“÷´ÁFFÉf<LŠ’! İ¥F÷*»ë$ ¸Œ2‰·Èb„ ò@¹tĞëÊª8·Y"“Êü„$íÛ¸¼{‹C{šl`g‰©L‘c¦åÿFFĞFS†Ü"S	}9
—dT{Ğ_ÿ@ó$*>ìc™ş2”ì\‡ÌNˆ×±îØ—6]ñÄî—`XR¦= „ñ'şøŸkÓF ¹/´ÉL¹åôÄõÏï?oJ&İpŞ¡ünàHÔİg#¿v¦1oÊÙ•
p&ø\MO@Æ¢Š›äO¶Åj1[`Úï?$Cœ"….Êå±ÍµÂ$q¬5©ŠîaiI¹]qÜ	•Åjo9Á;
Ş@¤yˆ —–]ÊƒÌõ/2¡7ı•Hÿ4%×œw;PDÛ†Ã… >·àrÁRªWañßvØí;º»©ƒMöìùÓNfİâO´È9Î¦xÖÛgîêœ{3Ïë:È8€Ï¶Ûdûâ0mş†ğ~5¥°¡pSšÁ6š\Ë^÷z½wZÙößsh¿Ê1ğ’ÇŸ‰	û>2erØ]†½Ëšò2Ö&/‹…@¶3o‹wQö8ÊòÉoZâËÓ:úvÜoªoÇ‘~¤2™{tUˆ<×[`L82¸cëĞ¾÷6ÔO’ˆ[™ÑÎ¯½Æ@¾ÿ­B˜¶ø*r·Í?Áì=ïî{ÿÊO ÖÕò§-0¶35'*¶øXÒu5ö§‚Ââ²‡j¨o1# Ê^&=­¦)È„ˆ‹œíÆí¥ú.~ò/T–ËÌªw,¿"ÛEƒ¹Ğ¸ç§ê½cYnü÷W
whu|{s¸C9\Ã	7şóÂ}lf+û"ñ¥ëÑwB½í\E åC¸Î^ñ×ªñàÕ×V½HĞB¶N°ëxÓF3­Kæ&œ°…Jñì‡xöAá0iØqû¸ı	§Ãík–—¢³¥ûp‰ß£à˜‚ZâNpçw­”ÿo”JÜ€&øGj‚sââOï[#ÿÏªòCa4]ñ4Š¿•pÅßä75Ø£šèª›(˜àµ&|Åß! ÛŞdH;îÍmô³|@XW=öäh´áö±kïVå ÊXi*ª„ÿ5ŸÆ„v†0Vü-OÕ REÂ\=JÖRvwÿ«økŸø×pşÀŠkş`zPPTQ„ïF#<8ÀL¸Cd¸5”ÆıÊÒ0ê9X†3•ŸBŒ³l2F€! Î‰ (#6D $ùEÀ ¸ ÿµ­Âp%â«ÒRÜ?'H]ñï[ÇJ÷Ààßù.íã™Ñ„îÌDÚ‹bp)¾HUÊ+,ò¸®ÓÅ3¾º¼H†z$c¡Áãh…íÉÇ¤´ËÃv‰Ø'ªò›¥RåHÚ‚l	HDa¼*¼!÷*´FWâÚ„çBµÌP2±CÛmc¿Éƒ~ÿa?‡K_ÉÌ …Å]½€4İÒ;Pse482Å=•é•’È†& œŸ›-¦wÏ¸oû'ÅqXuŸø.¿	|÷m#êõ‰µáÆ^¸åL	;ÈøšV)åbØwõû1ú}âcÌzïcş·w1ë½k\/êÿîAnÉß¶y~£§r8äS°­ìêÎïDï}”I–ûÖ½º	+cnåHÕ ƒïQêJÒ²V€ÃÀá
pD  G/…=P7w§ª R§Ş¥G™¥&Èvl(	xÁ=óXª##\¶şL>[4»ü€#ÓU¾–jÒÖ¨W´¡¾B2xÅÈª€™ê€Y—g<DÙõtpacLÌ[Njhš_rĞ™˜I†oráß¨Q†Å©§¸h{Ù-Œ’dkÖ£]6ë2ÆÅ™ÀTñQPüL™u9Î$SµşXŠ>q‡M/$Z¶ßU”½¥?®á5@^ª<Şä¥J|kH@ÿ=ÍTk•×Ô]«\n†K†Â—OĞĞfhÈ HÎñ(ñõÔËÍÚÕC@¢«‡DÁ«o`®Fàˆ+\=ŒÀq¸z#êLÇp8¤Wµjı±G—º(İÖH4…
ÁŠ/l?XDÑ¸¡'û×'BmgK—x Ån_íŠH´šb(BQ
)\öÇï2Ñş¡Ğ/#ÿií`äHq‘§ıC¡?°aPd‡<¶r?w¹‡2—{öß!\î4XÀ!ŠêŒ[‚>¯ô6º¬•Ü—­2õ±úğ°T•~š“(KğëŸ‹éÛS4·…_l&'å~¬Ä¯ ÛMpÃ2ºÉHş/Óù3¤súßå^k¥ê	W«ïª G$÷ó'ÁùÙÍ@uK°'™ŸË"G¦,£H¥«üİMx2ï’Ö‘4U:Äd)Ğª	²—¡¿²š£§yú6²óùÎ“æxà­¦Oy¤qz"/!¥‚K¶ÊºI‹èAaŠ)..®O…;.¦áã‰^Êœ&—}x|7™ßzXš&FšÒnA]º‹E˜XN'ñà¯”dıàÏpp¯¾»ÓôŒ«İqFâYçÙ.Šm¯Å$pWO'RHÛâ”)c+}°³Õ1ÓMcıó`ñµ«Ù—9äb™ ûÁÁ¿-bü‡÷/ ôª"˜à‰ÊßÈIâÕ[ÑÁo5Ì‘aÿ-Ë$S§<
Ërà%­`Láææ²Í™pİ"c¤'ñøòÇğ˜áÉT³OæÆù\Ø8û©Ôøù¼µªË'«:¼&¨Ãk Œï&à’¢×k‡b¹Ûd#,‡‘ùÛ¸á=,ŠÅÒVë&¹¥Ò¡ŒÜØ‚_ÛggjÒsôc” xCº;Î¼å·¦Ñ`çDİ[F‰2Ló¿Äæ'y‚3jÑoy­Ò>ÖÒH¾­KGWÉxœ«”öm§”‡µ¬<ÌõAÛ¸ÜÎ¹)æC©fQûbP‘]Jœ™ñÇDbœÓƒˆ¶çL2?+ÊÁ­jj“B[b#+h‘Øz†NCŞ«R³°:5;)í'»¸!ñÎQì.Ã<‹èd…RÊê]¿éïêRÍ¬¨*E_ÖDÖ)Md]D!IÈËm‚=Óêê!§håã<­|œOÎİ Ä¹äÜÎ3µJr–v­ƒ£ëµÎrª†¦¡§ë(Î =%TjÊgÓoN©ÑoNÑúÄw)#ğó£úM~nT_‰ÀifÌp8êO8RêC8’›­GÚÃ]Ğ‘­G®„»²:ıJIBª‹?Ô:Æy¤¸ìá†9¢&M7ÒÉ¾ëwµ
r«ø®æ§ıCa®eÅ—Ü@†„ª<Å†ÃàÚÎ*Ï¹,Â'¡‹#\Ï4µŠFÕ€ÕÔ7µw@]çi	´Ÿ%8‹·°†Oq™&Ö~Mˆ{¶ØµrÙS<IÔş!SsÀsÌ`Ÿ4HÜ9Ñ,ƒ§x–f¥ıCºŞ‰=¹xPÙŠwhbíWõµ®ø¨&Ğ~E€êW|Uh¿"@=,şUhÿPX«kÀÑäÀSl^×şhpÎ™3¸ü¾ºpî‘•ªz
0—Š¿ÄÕÊğ)a­¨±6µ`¡¶6µ—k„F§Úı/‡òú21i«VÕUuäúF÷OÛMvé·Ø|q›œEâCér©¨øÒ—Kßä.V>db“Ç>§àËnÚmŠ/aİ«ÓU™B{tä